/*** INITIALISATION ***/
DROP DIMENSION PRODUIT_DIM;
DROP DIMENSION TEMPS_DIM;
DROP DIMENSION LIEU_DIM;
DROP DIMENSION CLIENT_DIM;

DROP MATERIALIZED VIEW FAIT_VENTE;
DROP MATERIALIZED VIEW PRODUIT_VIEW;
DROP MATERIALIZED VIEW LIEU_VIEW;
DROP MATERIALIZED VIEW CLIENT_VIEW;
DROP MATERIALIZED VIEW TEMPS_VIEW;

/*** QUESTION D'IMPLÉMENTATION ***/
-- QUESTION 1
-- On utilise build immediate car nous voulons que la requête soit executée immediatement et que son résultatest stocké dans l'objet Vue Matérialisée car je ne vois pas l'utilité de d'attendre un raffraichissement dans ce cas.
-- On utilise refresh force afin que ce soit optimisé, cela veut dire qu'il utilise un refresh complete lorsque le refresh fast ne vaut pas le cout.
-- On utilise on commit car notre systeme evoluera beaucoup. C'est plus couteux, mais dans un systeme de vente / commerce il est utile d'avoir régulierement des informations à jour.
CREATE MATERIALIZED VIEW PRODUIT_VIEW BUILD IMMEDIATE REFRESH FORCE AS 
SELECT 
    NUM AS ID, 
    REGEXP_SUBSTR(DESIGNATION, '[^.]+', 1, 1) AS NOM,
    REGEXP_SUBSTR(DESIGNATION, '[^.]+', 1, 2) AS CATEGORIE,
    REGEXP_SUBSTR(DESIGNATION, '[^.]+', 1, 3) AS SOUS_CATEGORIE
FROM PRODUIT;
          
SELECT * FROM PRODUIT_VIEW;
          
          
CREATE MATERIALIZED VIEW LIEU_VIEW BUILD IMMEDIATE REFRESH FORCE AS 
SELECT 
    NUM AS ID,
    REGEXP_SUBSTR(ADRESSE, '[^,]+', 1,2) AS CODE,
    REGEXP_SUBSTR(ADRESSE, '[^,]+', 1,3) AS VILLE,
    REGEXP_SUBSTR(ADRESSE, '[^,]+', 1,4) AS PAYS 
FROM CLIENT;

SELECT * FROM LIEU_VIEW;


CREATE MATERIALIZED VIEW CLIENT_VIEW BUILD IMMEDIATE REFRESH FORCE AS 
SELECT 
    NUM AS ID,
    TRUNC(MONTHS_BETWEEN(SYSDATE, DATE_NAIS)/12) AS AGE,
    CASE 
      WHEN TRUNC(MONTHS_BETWEEN(SYSDATE, DATE_NAIS)/12) < 30 THEN '<30 ANS'
      WHEN TRUNC(MONTHS_BETWEEN(SYSDATE, DATE_NAIS)/12) < 45 THEN '30-45 ANS'
      WHEN TRUNC(MONTHS_BETWEEN(SYSDATE, DATE_NAIS)/12) < 60 THEN '45-60 ANS'
      ELSE '>60 ANS'
    END AS GROUPE,
    UPPER(SUBSTR(SEXE,0,1)) AS SEXE
FROM CLIENT;

SELECT * FROM CLIENT_VIEW;


CREATE MATERIALIZED VIEW TEMPS_VIEW BUILD IMMEDIATE REFRESH FORCE AS 
SELECT 
    NUM AS ID,
    TO_CHAR(DATE_ETABLI, 'DDD') AS NUM_JOUR,
    TO_CHAR(DATE_ETABLI, 'DAY') AS LIBELLE_JOUR,
    TO_CHAR(DATE_ETABLI, 'WW') AS SEMAINE,
    TO_CHAR(DATE_ETABLI, 'MONTH') AS MOIS,
    TO_CHAR(DATE_ETABLI, 'Q') AS TRIMESTRE,
    TO_CHAR(DATE_ETABLI, 'YYYY') AS ANNEE
FROM FACTURE;

SELECT * FROM TEMPS_VIEW;


CREATE MATERIALIZED VIEW FAIT_VENTE BUILD IMMEDIATE REFRESH FORCE AS 
SELECT 
  C.NUM AS ID_LIEU,
  C.NUM AS ID_CLIENT,
  L.PRODUIT AS ID_PRODUIT,
  L.FACTURE AS ID_TEMPS,
  P.REMISE AS REMISE,
  L.QTE AS QTE,
  P.PRIX AS PRIX_UNIT,
  L.QTE * P.PRIX * (100 - P.REMISE) AS PRIX_VENTE
FROM LIGNE_FACTURE L
  JOIN FACTURE F ON L.FACTURE = F.NUM
  JOIN PRIX_DATE P ON L.ID_PRIX = P.NUM
  JOIN CLIENT C ON F.CLIENT = C.NUM;
 
SELECT * FROM FAIT_VENTE;
 
 -- QUESTION 2
 -- CELA EST FAIT DIRECTEMENT PAR LE LOGICIEL
ALTER MATERIALIZED VIEW CLIENT_VIEW 
ADD CONSTRAINT PK_CLIENT_VIEW PRIMARY KEY (ID);

ALTER MATERIALIZED VIEW PRODUIT_VIEW
ADD CONSTRAINT PK_PRODUIT_VIEW PRIMARY KEY (ID);

ALTER MATERIALIZED VIEW TEMPS_VIEW
ADD CONSTRAINT PK_TEMPS_VIEW PRIMARY KEY (ID);

ALTER MATERIALIZED VIEW LIEU_VIEW
ADD CONSTRAINT PK_LIEU_VIEW PRIMARY KEY (ID);

ALTER MATERIALIZED VIEW FAIT_VENTE
ADD (
  CONSTRAINT PK_FAIT_VENTE PRIMARY KEY (ID_LIEU, ID_TEMPS, ID_CLIENT, ID_PRODUIT),
  CONSTRAINT FK_VENTE_LIEU FOREIGN KEY (ID_LIEU) REFERENCES LIEU_VIEW (ID),
  CONSTRAINT FK_VENTE_TEMPS FOREIGN KEY (ID_TEMPS) REFERENCES TEMPS_VIEW (ID),
  CONSTRAINT FK_VENTE_CLIENT FOREIGN KEY (ID_CLIENT) REFERENCES CLIENT_VIEW (ID),
  CONSTRAINT FK_VENTE_PRODUIT FOREIGN KEY (ID_PRODUIT) REFERENCES PRODUIT_VIEW (ID)
);
 
 -- QUESTION 3
INSERT INTO LIGNE_FACTURE VALUES (21, 25, 30, 31);
INSERT INTO LIGNE_FACTURE VALUES (31, 35, 40, 41);
INSERT INTO LIGNE_FACTURE VALUES (41, 45, 50, 51);
INSERT INTO LIGNE_FACTURE VALUES (51, 55, 60, 61);
INSERT INTO LIGNE_FACTURE VALUES (61, 65, 70, 71);

SELECT * 
FROM FAIT_VENTE 
WHERE ID_PRODUIT = 25
  OR ID_PRODUIT = 35
  OR ID_PRODUIT = 45
  OR ID_PRODUIT = 55
  OR ID_PRODUIT = 65;

--QUESTION 4
-- REMARQUE : LES INDEX POUR LES CLÉS PRIMAIRES SONT CRÉÉS AUTOMATIQUEMENT.
-- POUR LES NOMS
CREATE INDEX INDEX_PRODUIT_NOM
ON PRODUIT_VIEW (NOM);

CREATE INDEX INDEX_PRODUIT_CATEGORIE
ON PRODUIT_VIEW (CATEGORIE);

CREATE INDEX INDEX_PRODUIT_SOUS_CATEGORIE
ON PRODUIT_VIEW (SOUS_CATEGORIE);

-- POUR LES LIEUX
CREATE INDEX INDEX_LIEU_CODE
ON LIEU_VIEW (CODE);

CREATE INDEX INDEX_LIEU_VILLE
ON LIEU_VIEW (VILLE);

CREATE INDEX INDEX_LIEU_PAYS
ON LIEU_VIEW (PAYS);

-- POUR LES CLIENTS
CREATE INDEX INDEX_CLIENT_AGE
ON CLIENT_VIEW (AGE);

CREATE INDEX INDEX_CLIENT_GROUPE
ON CLIENT_VIEW (GROUPE);

CREATE INDEX INDEX_CLIENT_SEXE
ON CLIENT_VIEW (SEXE);

-- POUR LES TEMPS
CREATE INDEX INDEX_TEMPS_NUM_JOUR
ON TEMPS_VIEW (NUM_JOUR);

CREATE INDEX INDEX_TEMPS_LIBELLE_JOUR
ON TEMPS_VIEW (LIBELLE_JOUR);

CREATE INDEX INDEX_TEMPS_SEMAINE
ON TEMPS_VIEW (SEMAINE);

CREATE INDEX INDEX_TEMPS_MOIS
ON TEMPS_VIEW (MOIS);

CREATE INDEX INDEX_TEMPS_TRIMESTRE
ON TEMPS_VIEW (TRIMESTRE);

CREATE INDEX INDEX_TEMPS_ANNEE
ON TEMPS_VIEW (ANNEE);

-- QUESTION 5
-- REMARQUE : JE NE SAIS PAS LE BUT DES ATTRIBUTES.
CREATE DIMENSION PRODUIT_DIM
LEVEL NUMERO IS(PRODUIT_VIEW.ID)
LEVEL SOUS_CATEGORIE IS(PRODUIT_VIEW.SOUS_CATEGORIE)
LEVEL CATEGORIE IS(PRODUIT_VIEW.CATEGORIE)
HIERARCHY PROD_ROLLUP (NUMERO CHILD OF SOUS_CATEGORIE CHILD OF CATEGORIE);

EXECUTE DBMS_DIMENSION.VALIDATE_DIMENSION ('PRODUIT_DIM', FALSE, TRUE, 'TEST DE LA DIMENSION PRODUIT');


CREATE DIMENSION LIEU_DIM
LEVEL NUMERO IS(LIEU_VIEW.ID)
LEVEL CODE IS(LIEU_VIEW.CODE)
LEVEL VILLE IS(LIEU_VIEW.VILLE)
LEVEL PAYS IS(LIEU_VIEW.PAYS)
HIERARCHY PROD_ROLLUP (NUMERO CHILD OF VILLE CHILD OF CODE CHILD OF PAYS);

EXECUTE DBMS_DIMENSION.VALIDATE_DIMENSION ('LIEU_DIM', FALSE, TRUE, 'TEST DE LA DIMENSION LIEU');


CREATE DIMENSION CLIENT_DIM
LEVEL NUMERO IS(CLIENT_VIEW.ID)
LEVEL AGE IS(CLIENT_VIEW.AGE)
LEVEL GROUPE IS(CLIENT_VIEW.GROUPE)
LEVEL SEXE IS(CLIENT_VIEW.SEXE)
HIERARCHY PROD_ROLLUP (NUMERO CHILD OF AGE CHILD OF GROUPE CHILD OF SEXE);

EXECUTE DBMS_DIMENSION.VALIDATE_DIMENSION ('CLIENT_DIM', FALSE, TRUE, 'TEST DE LA DIMENSION CLIENT');


CREATE DIMENSION TEMPS_DIM
LEVEL NUMERO IS(TEMPS_VIEW.ID)
LEVEL JOUR IS(TEMPS_VIEW.NUM_JOUR)
LEVEL SEMAINE IS(TEMPS_VIEW.SEMAINE)
LEVEL MOIS IS(TEMPS_VIEW.MOIS)
LEVEL TRIMESTRE IS(TEMPS_VIEW.TRIMESTRE)
LEVEL ANNEE IS(TEMPS_VIEW.ANNEE)
HIERARCHY PROD_ROLLUP (NUMERO CHILD OF JOUR CHILD OF SEMAINE CHILD OF MOIS CHILD OF TRIMESTRE CHILD OF ANNEE);

EXECUTE DBMS_DIMENSION.VALIDATE_DIMENSION ('TEMPS_DIM', FALSE, TRUE, 'TEST DE LA DIMENSION TEMPS');

/*** QUESTION D'IMPLÉMENTATION ***/
-- QUESTION 1
SELECT F.ID_PRODUIT, P.NOM, SUM(F.PRIX_VENTE) AS CA
FROM FAIT_VENTE F
  JOIN PRODUIT_VIEW P ON F.ID_PRODUIT=P.ID
GROUP BY F.ID_PRODUIT, P.NOM
ORDER BY CA DESC;

-- QUESTION 2
SELECT P.CATEGORIE, T.MOIS, SUM(F.PRIX_VENTE) AS CA 
FROM FAIT_VENTE F
  JOIN PRODUIT_VIEW P ON F.ID_PRODUIT=P.ID
  JOIN TEMPS_VIEW T ON F.ID_TEMPS=T.ID
GROUP BY ROLLUP (P.CATEGORIE, T.MOIS);

-- QUESTION 3
SELECT C.GROUPE, SUM(F.PRIX_VENTE) AS CA, 
  RANK() OVER (ORDER BY SUM(F.PRIX_VENTE) DESC) AS RANG 
FROM FAIT_VENTE F
  JOIN CLIENT_VIEW C ON F.ID_CLIENT=C.ID
GROUP BY C.GROUPE;

-- QUESTION 4
SELECT * 
FROM (
  SELECT P.NOM, SUM(F.QTE) AS QUANTITE_VENDUE, 
    RANK() OVER (ORDER BY  SUM(F.QTE) DESC) AS RANG
  FROM FAIT_VENTE F
    JOIN PRODUIT_VIEW P ON F.ID_PRODUIT=P.ID
  GROUP BY NOM
)
WHERE RANG<=3;